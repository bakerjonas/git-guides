\documentclass[a4paper,10pt]{article}
\usepackage[english]{babel}
\usepackage[OT1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
\usepackage{mydoc}
\usepackage[pdftex,colorlinks=true,
				 pdfstartview=FitV,
				 linkcolor=blue,
				 citecolor=blue,
				 urlcolor=blue,
		  ]{hyperref}

\begin{document}
\pagestyle{fancy}
\fancyfoot{}
\fancyhead{}
\renewcommand{\sectionmark}[1]{\markboth{\sf\thesection.\ #1}{}}
\renewcommand{\subsectionmark}[1]{}
\fancyhead[R]{{\rmfamily\thepage}}

\title{Git in a Nutshell}

\subtitle{for normal people (version 0.1)}
\author{{\sf Jonas Jus\'elius}}
\address{
{\tt <jonas.juselius@chem.uit.no>}\\
{\sf University of Tromsø}\\
{\sf Department of Chemistry}\\
{\sf N-9037 University of Tromsø, Norway}
}
\years{2007}
\abstract{Rev.1:\\{\tt git clone http://git.jonas.iki.fi/CVS2git.git}\\
Corrections and improvements are most welcome via e-mail using the
{\tt git-format-patch} facility.}

\maketitle
\section*{About this document}
The intent of this document is to explain some of the aspects of working with
git that I feel are somewhat poorly explained elsewhere. Most git commands
have excellent man pages explaining in excruciating detail the particular
command. What I feel is missing is a manual which explains what the commands
are for, how the pieces fit together and how to actually work with git on a
daily basis. This guide has been written with an audience consisting of the
typical academic programmer in mind, and relies implicitly on a repository
setup as outlined in the Git to CVS Migration Guide.

Finally a disclaimer. I'm not an expert on git, nor do I have a huge
experience working with git. All comments, corrections and suggestions are 
most welcome!

\section{Introduction to git}
Git is different from CVS in most respects. When you clone a repository you
get the WHOLE repository, everything, not just a working copy like in CVS!
\texttt{git-clone} is almost the same as doing a
\begin{verbatim}
$ scp -r myserver:/path/to/myrepo .
\end{verbatim}
Within this personal repository you can do \textit{whatever} you like, i.e. create
branches, delete branches, tags, and of course commit as much as you ever
like. It's only when you push to the master that others can see your changes.
In fact, your (cloned) repository can act as a master for someone else! The
division into master and client is really quite blurred and artificial in git.
When you clone a repository, the new copy will contain administrative
information in .git/config about where it was cloned from, and have a slightly
modified branch structure (as you will see), but apart from this it's
identical to it's parent. And where we humans can't choose nor change who our
parents are, git has no problem in changing or removing the parent(s).

\section{Branches in git}
\subsection{Remote branches}
The thing that differs most from CVS when working with git is the use of
branches. Under git branches are used extensively, and they are essentially
free. It costs nearly nothing to create branches, both in terms of time and
disk space. There is also no need to tag first and branch second, like in CVS.

When you clone a repository
(this is called the 'remote' repository, and is referred to as the 'origin')
all the branches in that repo are renamed in your local copy by prefixing the
branch name with '\texttt{origin/}'. These branches are called 'remote
branches' or 'tracking branches', to distinguish them from \emph{your}local
branches.  \texttt{git branch -r} show all remote branches. When you run
\texttt{git-fetch origin} \emph{all} remote branches are updated to the exact
state of the remote repository. Now you can inspect the changes on those
branches by either using \texttt{gitk}, or a combination of \texttt{git-log},
\texttt{git-whatchanged}, \texttt{git-diff} and \texttt{git-annotate}, e.g. to
inspect changes on the most important remote branch: \texttt{gitk
origin/master}. Note
that \texttt{git-fetch} updates the remote tracking branches, not your working branches!
Never, ever, checkout a remote branch directly unless you absolutely want
trouble. 

\subsection{Tracking remote branches}
In order to incorporate changes in in remote branches you need to merge your
working copy with the remote branch, e.g. (\texttt{git-checkout mybranch}),
\texttt{git-merge
origin/master}. If you get a conflict, run \texttt{git-mergetool} which will fire up the
merge tool of your choice. When you have resolved all issues, run
\texttt{git-commit}
to complete the merge. The \texttt{git-pull} command basically does a
\texttt{git-fetch} and
\texttt{git-merge} in one go. I recommend you \emph{do not} use it unless you very carefully
read the man page first, since it has some pitfalls!

As I mentioned earlier, never work on a remote branch directly! This will
cause terrible problems when you try to sync with the remote repository.
Instead create a local branch \emph{from} the remote branch and do your work
on it instead: \texttt{git-branch foobar origin/foobar}; \texttt{git-checkout
foobar}. After a \texttt{git-fetch} run \texttt{git-merge origin/foobar} to
get the latest updates on the branch (and also \texttt{git-merge
origin/master} if you want to track the "official" changes).  When you feel
you have something worth showing to others (or just for backup) you can push
your changes on some branch to your personal branch on the master server, i.e.
the remote repository, \texttt{git-push origin mybranch:myuserid}.

\subsection{Daily git}
All this might sound a bit confusing, so here are my recommendations for
how to work with git until you get used to it:
When you clone the master repo, you will get a set of remote branches
(\texttt{git-branch -r}), and one local working branch called 'master'. This branch is
in the exact state of the remote master branch (i.e. origin/master and master
are identical). I suggest you keep it this way, and create a working branch
for yourself, e.g. 

\begin{verbatim}
$ git-branch work
$ git-checkout work 
\end{verbatim}

Now work like you normally do, and every now and then (every morning for
example) do

\begin{verbatim}
$ git-fetch origin
$ gitk origin/master
# if you like what you see
$ git-merge origin/master 
\end{verbatim}

Every time you have made changes which can be considered complete in some
sense (you know best), do a commit (it's much better with many small commits
than a few big commits as you will see):

\begin{verbatim}
$ git-status
$ git-add file(s)
$ git-commit 
\end{verbatim}

\subsection{The goal}
With so many possibilities for organising both repositories and branches it's
important not to forget that the ultimate aim should be to get your beautiful
new features merged with the master branch on the master server! It's like the
musketeers, ``All for one, one for all!''. 

It's important to update often from the master repository, partly not to drift
too far away from the master branch, and also to incorporate all bug fixes
etc. At the same time it's also important to push to the master often and in
small increments, since this makes it a lot easier for other developers to
stay in sync with \emph{your} work.

\section{Cherry picking}
There are of course still lots nice tricks we can play with
branches. Suppose you want to try out some idea, but you don't know exactly
how it will work out. Create a new branch from your current working branch and
check it out:
\begin{verbatim}
$ git-branch foobar
$ git-checkout foobar
\end{verbatim}
Now work hard and commit often. If it turns out that everything is good, and
you want to keep all changes, merge them with your working branch and push
them to the master:
\begin{verbatim}
$ git-checkout work
$ git-merge foobar
$ git-push origin work:myuserid
\end{verbatim}
Now you can delete the foobar branch for ever and all times
\begin{verbatim}
$ git-branch -d foobar
\end{verbatim}
If, on the other hand it turn's out that you had a crackpot idea, and you
don't want to see any of it anymore, delete the branch and all changes,
commits and everything on the branch will be gone for ever! No trace of it.
But what if there are partially useful changes to foobar that you want to
keep, before discarding the rest? Well that's when small commits are useful
because you can cherry pick! Chekout your work branch, fire up gitk on foobar,
and find the commits you like to keep. Every commmit is identified by a long
SHA1 hash (a long sequence of numbers and letters). Now cherry pick the
commits you want into the work branch:
\begin{verbatim}
$ git-checkout work
$ gitk foobar &
# find commit, copy the SHA1 hash with the mouse
$ git-cherry-pick SHA1
\end{verbatim}
Repeat the cherry pick as many times you like. As you see, git gives a lot of
flexibility by using branches. Just be a bit careful in the beginning not to
make a mess and lose track of what you are doing. 

\subsection{Remote repositories}

\subsection{Stashing}
Sometimes when you are working on a branch you temporarily need to switch to
another branch to test something, or maybe fix a bug. In a situation like this
you cannot just checkout the other branch, since then all your local changes
would get lost (don't worry, git will not allow you to do this). However, you
might not want to commit your changes either, since they are not ready or
complete. In situations like this git allows you to temporarily commit your
changes in a ``stash''. Running \texttt{git-stash} saves your latest changes
and resets the current branch to it's latest checked in state (the HEAD). When
you are ready to continue working you just apply changes in the stash.
\begin{verbatim}
$ git stash save
$ git stash list
stash@{0}: WIP on mybranch: ad6d0aa... foo
$ git checkout other branch
...
$ git checkout mybranch
$ git stash apply
$ git stash clear
\end{verbatim}


\subsection{Resolving conflicts}
Every now and then you end up in a situation where files have overlapping or
incompatible changes. This will be flagged as a conflict by git, and you will
have to resolve the conflict before you can proceed. There 

\subsection{Exporting a repository}
\subsection{Resetting}
\subsection{Finding bugs}
\subsection{Odds and ends}
git-mv, git-rm, git-grep, git-whatchanged, git-blame

\section{Using git for collaboration}
Revision management goes well beyond just source code management for a group
of programmers. Revision management is useful for most tasks which are
expected to evolve with time, like for example manuscripts.
Since git is very easy to set up, and supports a wide range of communication
protocols, git can be useful for many collaborative tasks. In the following
section we will examine how git can be used to collaborate in a highly
disconnected environment, where none of the participants have access to a
common server or each others machines. This is a typical situation which
arises for shorter term projects, like when collaborating on a scientific
manuscript. To facilitate this situation git offers a powerful e-mail facility
for communication changes.

Suppose you are working on a LaTeX manuscript and you want to have the whole
manuscript under revision control:
\begin{verbatim}
$ cd ~/tex/manus/
$ git init
$ git add manus.tex fig1.ps fig2.ps
$ git commit
\end{verbatim}
That's it! Now you can work happily, and remember commit every now and then so
that you always can go back in history if you need to. 

At the point when you are ready to send the manuscript to your collaborators,
you can either clone your repository in /tmp to obtain a clean copy, or just
clean out all unnecessary files. Then make an archive of the whole archive and
send it by email to your collaborators\footnote{If the file is very big it's
probably better to provide a (hidden) link to your home page, as many mail
servers will not accept excessively large files}. 
\begin{verbatim}
$ cd /tmp
$ git clone ~/tex/manus
$ tar vfcz ~/tex/manus.tgz manus
$ rm -rf manus
# mail and attach ~/tex/manus.tex
\end{verbatim}

Now you and your collaborators continue to work the manuscript. After some
time, and a number of commits, it's time to share your changes with the 
others. The first step is to identify the commits you want to send. The
commits can easily be identified by running \texttt{git log}. Suppose you have
made 3 commits since you last distributed your changes:
\begin{verbatim}
$ git format-patch -3
\end{verbatim}
This creates 3 patch files in the current directory, which now can be attached
and sent to your collaborators using your favourite mailer. Alternatively you
can use \texttt{git-send-email} to do the job.
\begin{verbatim}
$ git-send-email --subject '[patch] my latest changes' --to foo@bar.org \
--cc raboof@foobar.edu --cc myself@myhost.net *.patch
$ rm *.patch
\end{verbatim}
\texttt{git-send-mail} can also be configured using \texttt{git-configure} to
avoid having to write the long command line every time.

When you receive changes from your collaborators by e-mail, just save the
mail(s) in your project directory and apply the changes:
\begin{verbatim}
$ git-am --3way mailfile(s)
$ rm mailfile(s)
\end{verbatim}
It might be a good idea to create and switch to a temporary branch before 
applying the patches, since this gives you better possibility to inspect the 
changes before merging them with your main branch. Obviously, if there is a
conflict it has to be resolved in the normal manner.
\end{document}

