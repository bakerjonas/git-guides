\documentclass[a4paper,10pt]{article}
\usepackage[english]{babel}
\usepackage[OT1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
\usepackage{mydoc}
\usepackage[pdftex,colorlinks=true,
				 pdfstartview=FitV,
				 linkcolor=blue,
				 citecolor=blue,
				 urlcolor=blue,
		  ]{hyperref}

\begin{document}
\pagestyle{fancy}
\fancyfoot{}
\fancyhead{}
\renewcommand{\sectionmark}[1]{\markboth{\sf\thesection.\ #1}{}}
\renewcommand{\subsectionmark}[1]{}
\fancyhead[R]{{\rmfamily\thepage}}

\title{CVS to git Transition Guide}

\subtitle{Guide for Cold Turkey Quitters}
\author{{\sf Jonas Jus\'elius}}
\address{
{\tt <jonas.juselius@chem.uit.no>}\\
{\sf University of Tromsø}\\
{\sf Department of Chemistry}\\
{\sf N-9037 University of Tromsø, Norway}
}
\years{2007}
\abstract{Rev.1:\\{\tt git clone
feynman.chemie.uni-mainz.de/mnt/software/git/juselius/CVS2git.git}\\
Corrections and improvements are most welcome via e-mail using the
{\tt git-format-patch} facility.}

\maketitle

\section{Preliminaries}
This guide attempts to document one way of migrating both repositories and 
users from  CVS to git. 
I'm sure there are many other equally good, or better, ways of doing 
this. I have called my scheme the Cold Turkey scheme, since it involves
freezing CVS in one go, and moving to git without attempting any kind of soft
transition period operating both CVS and git in parallel. 

This is not a git manual. There is a lot of decent
documentation available on the web, and all git commands are very well
documented, so there is no need to repeat them here. 
This document explains step-by-step how to move your local changes
in your CVS repositories to the newly created git repository. It assumes that
you have a recent version of git installed on your system, and that you have
familiarised your self with the basic git operations by reading the available
git documentation at \url{http://git.or.cz}. 

The first part of this guide is intended for repository administrators, and
documents step-by-step how to freeze the CVS archive and convert it to a git
archive. 

The second part is intended for the individual developer, documenting how to
set up git for personal use, and how to safely migrate all uncommitted changes
from CVS to git.

The third part of this guide discusses some good practices and aspects of 
using git on a daily basis.
It also tries to explains some of the differences between git and
CVS, which at first sight might be a bit hard to understand. Although git is
well documented, some of the documentation is somewhat scattered, or seems to
be written for computer scientists.

\subsection{Recommended reading}
If you have not done so yet, I
recommend you start by reading the following two short tutorials:
\begin{description}
\item[Git for CVS users]:\\
\url{http://www.kernel.org/pub/software/scm/git/docs/cvs-migration.html}
\item[The git tutorial]:\\
\url{http://www.kernel.org/pub/software/scm/git/docs/tutorial.html}
\end{description}
Furthermore, the following documents may be of use:
\begin{description}
\item[Everyday git with 20 commands or so]:\\
\url{http://www.kernel.org/pub/software/scm/git/docs/everyday.html}
\item[Git user's manual]:\\
\url{http://www.kernel.org/pub/software/scm/git/docs/user-maunal.html}
\end{description}

\subsection{About this document}
This guide was written as part of moving the ACES2 (\url{http://www.aces2.de})
program package from CVS to git. As such it reflects the 
practical choices made for this particular environment. 

Finally, I'm sure there are errors and/or semi correct statements in this
document since I'm not a true git expert (yet). All suggestions and
corrections are welcome!

\subsection{Conventions}
I have used the following conventions in this document: Commands are written 
in {\tt typewriter} and anything the user should replace with his/her own 
options have been enclosed in brackets, e.g. {\tt <mybranch>}.  

ACES2 developers should substitute the following values for these variables
\begin{description}
  \item{\tt <myserver>}: {\tt [uid@]feynman.chemie.uni-mainz.de}
  \item{\tt /path/to/repository.git}: {\tt /mnt/software/git/aces2.git}
  \item{\tt /path/to/my/repository.git}: {\tt /mnt/software/git/<uid>/aces2.git}
  \item{\tt <myuid>}: Your user id on feynman
\end{description}

\section{Converting CVS to git}


\section{Migrating your local CVS repository}
\subsection{Before you start}
Before doing anything else, I suggest that you setup some default
configuration variables for git. Git uses a number of config files, system
wide, per user and per repository (see the git-config man page for more info).
As a minimum you should set the following options:
\begin{verbatim}
$ git-config --global user.name "Your Name"
$ git-config --global user.email "my@email.com"
\end{verbatim}
These options are written in ~/.gitconfig, and are used by git to ensure that
your commit messages are sensible, since user names and mail addresses are not
necessarily set properly on all machines. In addition you might want to enable
the following options as well:
\begin{verbatim}
$ git-config --global color.branch auto
$ git-config --global color.status auto
$ git-config --global color.diff false
\end{verbatim}
In order to save space you can also enable compression
\begin{verbatim}
$ git-config --global core.compression 1
$ git-config --global core.loosecompression 1
\end{verbatim}
If you want to use some external (graphical) merge tool to resolve conflicts:
\begin{verbatim}
$ git-config --global merge.tool meld
\end{verbatim}
Meld is a fantastic merge tool, and I strongly suggest you have a look at it.
Other valid possibilities are kdiff3 and xxdiff (amongst others).

\subsection{Updating your CVS repository}
Since the old CVS server is no longer accepting new modifications, you need to
move all of your local modifications under git and then commit them. To do
this you need to follow these directions carefully. Before you start I
strongly suggest that you backup your working copy!
\begin{description}
\item[Update] The first thing you must do is to synchronise your working
copy with the CVS server by running
\begin{verbatim}
$ cvs update
\end{verbatim}
This makes sure that your files are in the right state. 
Files with local modifications will not be overwritten nor
updated. If you have modified files that meanwhile have been modified on the
master you will probably have a number of conflicts. You need to resolve these
conflicts before continuing. Edit the files with conflicts and pick the
correct pieces of code between the markers.
\item[Diff] The next step is to create a patch file to migrate all your
changes from CVS to your new git repository. 
Now that all files, except your locally modified files, are in the same state
as on the master you can run
\begin{verbatim}
$ cvs diff -u -N >migration.diff
\end{verbatim}
This file contains all the differences between the master and your working
copy.
\end{description}

\subsection{Setting up the git repository}
\begin{description}
\item[Clone] Now you are in a position to clone the new git master repository!
Change your working directory to where you want to create your new repository
and run
\begin{verbatim}
$ git clone user@feynman.chemie.uni-mainz.de:/mnt/software/git/aces2.git
$ cd aces2 
\end{verbatim}
Optionally you can also specify the name of the new repository.
\item[Branch and checkout] 
Before you do anything else you need to create a new (local) branch which is
in the same state as the old master CVS, and switch to the new branch. The new
branch will be called migration (or whatever) and must be created from the tag
CVS\_migration\_HEAD:
\begin{verbatim}
$ git branch migration CVS_migration_HEAD
$ git checkout migration
\end{verbatim}
\item[Patch] You are now ready to apply the patch you created and bring your
own local modifications into your git repository
\begin{verbatim}
$ patch -p0 < /path/to/old/aces2/migration.diff
\end{verbatim}
The patch should apply without a hitch if you have done everything correctly.
You can now run 
\begin{verbatim}
$ git status
\end{verbatim}
to show the status of your repository (i.e. modified files, deleted files,
files that needs to be added, etc.).
\end{description}

Congratulations! Your repository is now in the same state as before the 
switch!

\subsection{Committing your changes}
Before you add changes (and files) to
commit you should probably think closely about how changes are logically
related and how they could be grouped into sets, instead of committing
everything as one big blob. It's better to have many, many small commits than
a few big ones, since this helps picking out particular patch sets and
applying them to other branches (this is known as cherry picking).

\begin{description}
\item[Commit] The following step in the migration process is to commit all
your changes in your local repository. Don't worry, you will not mess up
anything on the master, or even make your changes public yet. This is a
personal commit so far. There is a convenient tool to pick, group and commit 
your changes
\begin{verbatim}
$ git citool
\end{verbatim}
If you rather do everything by hand, repeatedly run
\begin{verbatim}
$ git add file(s) 
$ git commit
\end{verbatim}
to group changes into sets, until all changes have been committed. 
This is also how you add untracked files to git.

Finally run 
\begin{verbatim}
$ git status
\end{verbatim}
to check that you have not missed anything. 

You can also just run
\begin{verbatim}
$ git commit -a
\end{verbatim}
to do what you probably should not, i.e. commit everything as one huge commit.
\end{description}

\subsection{Working with the master server}
Now that all your changes have been safely committed it's time to push them to
the master server so that others can see your changes, and for backup. Don't
worry, things have been set up such that you can't mess up the master
repository. 
The master repository has been set up with a number of default branches. 
In the (hopefully near) future a testing branch will be set up, as a staging area for
code that you want to have included in the main master branch. The code in
this branch will be checked out nightly and run through the test suite. If the
tests run cleanly, the code will be considered eligible for inclusion in the
master branch.
In addition every developer has the possibility to cerate their own branch on
the master (note that it's not created by default).  You can only commit
branches and tags which have names that start with your user id. 

\begin{description}
\item[Creating a remote branch] To create a new branch on a remote server, git
requires a very explicit syntax. After you have created the branch, you can
use the same syntax as when operating on local branches. To create a remote 
branch and push your changes in the migration branch to it, do
\begin{verbatim}
$ git push origin migration:refs/heads/<uid>
\end{verbatim}
where {\tt <uid>} is your login on the server.

\item[Fetching changes] To follow what others are doing and incorporating
their latest changes you need to regularly fetch their changes. git is very
flexible in the ways you can do things, so consult the man pages for more
info. To download all changes from the master run
\begin{verbatim}
$ git fetch origin 
\end{verbatim}
This downloads all remote branches and stores them in your remote tracking
branches (use {\tt git-branch -r} to see them). {\tt git-fetch} does not merge any changes
into your working branches. After the git-fetch you can examine the changes to
the remote branches using e.g. {\tt gitk --all} or 
{\tt git [log/diff] origin/master}.
To update your current branch with e.g. the remote master branch do
\begin{verbatim}
$ git merge origin/master
\end{verbatim}

\item[Pulling changes] There is a much easier way of updating your branches
from the master server:
\begin{verbatim}
$ git pull origin master
\end{verbatim}
This command automatically fetches the master branch from the server and
merges it with your current branch. This is more or less the git equivalent of
{\tt cvs update}. Note that this only fetches the specified branch from the
server. If you want all changes on all branches use the fetch command above.

\item[Push] To publish changes to a branch so that others can see them and
alternatively merge them with their branches you must push them to the main
server. This is in a sense the git equivalent of a {\tt cvs commit}. 
To upload a
branch and merge it with your personal branch on the server, do
\begin{verbatim}
$ git push origin somebranch:<uid>
\end{verbatim}
For more details see the git-push man page. Note that for a push to work, it
must result in a so called fast-forward-merge. Fast-forward means that the
files you want to merge on another branch, must have the files in the other
branch as parents. Simply stated, the files on the other branch have not
changed since the last pull.  If the push fails because it's not fast-forward,
you must first do a {\tt git pull origin branch} and resolve any conflicts 
before
(re)doing the push.

\item[Tagging] To create a tag, simply run {\tt git-tag <tagname>}. To push
your tags to the main server, do
\begin{verbatim}
$ git push --tags origin 
\end{verbatim}
This will push all your tags to the main server. Note that you are not allowed
by the server to create tags unless they are prefixed with your user id, e.g. 
{\tt <uid>/mytag}. If you don't want to push all tags, you can use the special
syntax
\begin{verbatim}
$ git push origin tag <uid>/<mytag>
\end{verbatim}
To delete a tag on the master you need to explicitly push an empty tag
\begin{verbatim}
$ git push origin :refs/tags/<uid>/<mytag>
\end{verbatim}

\item[Deleting a remote branch] If you for some reason want to delete a branch
on the remote server, just push an empty branch to the remote branch:
\begin{verbatim}
$ git push origin :<branch>
\end{verbatim}
\end{description}

If you want to have more
flexibility, more branches and tags (on the server) and more freedom
generally, you can also set up your own personal repository on the master. git
makes it quite easy to work with multiple remote repositories in one go. 

To set up your own sub-master repository follow these steps:
\begin{verbatim}
$ ssh feynman.chemie.uni-mainz.de
$ cd /mnt/software/git
$ mkdir $USER
$ git clone -s -l --bare aces2.git $USER/aces2.git
$ cd $USER/aces2.git 
$ git-branch -a 
# remove any branches and tags you do not care about
$ git-branch -D <branch branch...>
$ git-tag -d <tag tag...>
\end{verbatim}
The -s and -l options to {\tt git-clone} will cause git to set up the
repository to use the master's object database as much as possible, so that it
will take up very little space. 

Now on your local machine, cd to your development repository and register the 
new remote:
\begin{verbatim}
$ git-remote add <name> feynman:/mnt/software/git/<uid>/aces2.git
\end{verbatim}
Now when you fetch, pull and push use your new remote-tag {\tt <name>} instead 
of {\tt origin} to the corresponding command. The new development cycle will
typically be something like
\begin{verbatim}
$ git-pull origin master
# do some work
$ git push myremote mybranch:mybranch
# or to push all branches automatically
$ git push --all myremote 
\end{verbatim}

Since branches come and go, both in {\tt origin} and in your own remote(s)
it's a good idea to clean up the remotes once in a while by doing a
\begin{verbatim}
$ git-remote prune origin
$ git-remote prune <myremote>
\end{verbatim}

\section{Working with git}
o gitweb
o diff
o status
o branches and master -> why push
o how to track masters master

\section{Useful git commands}
Here is a short list of useful git commands to familiarise yourself with when
you feel that you have the basics under control. {\tt man git-<command>} will
give you all available information on a particular command.
\begin{description}
\item{\tt gitk} Graphical interface for browsing repositories.
\item{\tt qgit} Graphical interface for browsing repositories. Better and more
advance than gitk, but probably not installed on your system by default.
\item{\tt git-diff} View differences between your working copy and a committed
revision (and more).
\item{\tt git-gc} By default git will store all objects in a very primitive
and storage inefficient way. This command packs, compresses and prunes
unreachable objects in the object database. {\bf Should be used regularly}.
\item{\tt git-stash} If you need to checkout a new branch, but don't want to
commit your changes, stash allows you to temporarily save your changes. Only
in git 1.5.3 and newer.
\item{\tt git-cherry-pick} Instead of merging two complete branches, only pick the
commits you really want from a branch.
\item{\tt git-bisect} Find a commit which introduced some nasty bug. Very
helpful.
\item{\tt git-log} View the commit history on a branch
\item{\tt git-archive} Create a tar or zip archive from a branch.
\item{\tt git-mv} Rename files in the repository.
\item{\tt git-rm} Delete files from the repository.
\item{\tt git-annotate} Show who changed what and when in files.
\item{\tt git-format-patch} Generate an patch file of a commit, suitable for
sending by e-mail
\item{\tt git-am} Apply a patch from a mailbox

\end{description}

\end{document}

